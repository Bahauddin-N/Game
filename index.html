<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Princess Quest üíñ A Royal Adventure</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700;900&family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --pink: #ff6b9d;
      --dark-pink: #ff4d7d;
      --light-pink: #ffb3d9;
      --purple: #a855f7;
      --gold: #fbbf24;
      --dark: #1e0a2e;
      --darker: #120520;
      --red: #ef4444;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, var(--darker) 0%, #2d1b4e 50%, var(--darker) 100%);
      color: white;
      overflow: hidden;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 1200px;
      height: 100vh;
      max-height: 800px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 40%, #90ee90 100%);
      image-rendering: crisp-edges;
      image-rendering: pixelated;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      pointer-events: none;
      z-index: 10;
    }

    .hud-item {
      background: rgba(30, 10, 46, 0.95);
      border: 3px solid var(--gold);
      border-radius: 15px;
      padding: 10px 18px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 18px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
    }

    .hud-icon {
      font-size: 24px;
    }

    .hud-value {
      color: var(--gold);
      font-family: 'Cinzel Decorative', serif;
    }

    /* Health bar */
    #healthBar {
      width: 200px;
      height: 30px;
      background: rgba(30, 10, 46, 0.95);
      border: 3px solid var(--gold);
      border-radius: 15px;
      padding: 4px;
      position: relative;
      overflow: hidden;
    }

    #healthFill {
      height: 100%;
      background: linear-gradient(90deg, #ef4444, #f97316);
      border-radius: 10px;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
    }

    #healthText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: 900;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      z-index: 1;
    }

    /* Story Box */
    #storyBox {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(30, 10, 46, 0.98);
      border: 4px solid var(--gold);
      border-radius: 20px;
      padding: 20px 30px;
      max-width: 700px;
      width: 90%;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
      z-index: 50;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
    }

    #storyBox.show {
      opacity: 1;
      pointer-events: auto;
    }

    #storyBox h3 {
      font-family: 'Cinzel Decorative', serif;
      font-size: 24px;
      margin-bottom: 10px;
      color: var(--gold);
    }

    #storyBox p {
      font-size: 16px;
      line-height: 1.6;
      color: #fff;
    }

    #storyBox button {
      margin-top: 15px;
      padding: 10px 30px;
      background: linear-gradient(135deg, var(--pink), var(--purple));
      border: 3px solid white;
      border-radius: 10px;
      color: white;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s ease;
      font-family: 'Cinzel Decorative', serif;
      pointer-events: auto;
    }

    #storyBox button:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(255, 107, 157, 0.5);
    }
    
    #storyBox button:active {
      transform: scale(0.98);
    }

    /* Controls */
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(30, 10, 46, 0.95);
      border: 3px solid var(--pink);
      border-radius: 15px;
      padding: 15px 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      z-index: 10;
    }

    #controls div {
      margin-bottom: 8px;
      font-size: 15px;
    }

    #controls div:last-child {
      margin-bottom: 0;
    }

    #controls strong {
      color: var(--gold);
      font-family: 'Cinzel Decorative', serif;
    }

    /* Toast */
    #toast {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, var(--pink), var(--purple));
      border: 4px solid white;
      border-radius: 20px;
      padding: 25px 40px;
      font-size: 22px;
      font-weight: 700;
      text-align: center;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 100;
      max-width: 90%;
      font-family: 'Cinzel Decorative', serif;
    }

    #toast.show {
      opacity: 1;
    }

    /* Modal */
    #modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      backdrop-filter: blur(10px);
    }

    #modal.show {
      display: flex;
    }

    #modalContent {
      background: linear-gradient(135deg, #2d1b4e 0%, #1e0a2e 100%);
      border: 5px solid var(--gold);
      border-radius: 30px;
      padding: 60px 50px;
      max-width: 650px;
      width: 90%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
      animation: modalSlide 0.5s ease;
      position: relative;
    }

    @keyframes modalSlide {
      from {
        opacity: 0;
        transform: translateY(-50px) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    #modalContent h1 {
      font-family: 'Cinzel Decorative', serif;
      font-size: 52px;
      margin-bottom: 25px;
      background: linear-gradient(135deg, var(--pink), var(--gold), var(--purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1.2;
    }

    #modalContent p {
      font-size: 26px;
      margin-bottom: 40px;
      color: var(--light-pink);
      font-weight: 600;
    }

    .button-container {
      position: relative;
      width: 100%;
      height: 140px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn {
      font-family: 'Cinzel Decorative', serif;
      font-size: 24px;
      font-weight: 700;
      padding: 20px 60px;
      border: 4px solid white;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.15s ease;
      text-transform: uppercase;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      position: absolute;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #yesBtn {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      z-index: 10;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    #yesBtn:hover {
      transform: translate(-50%, -50%) scale(1.12);
      box-shadow: 0 15px 40px rgba(16, 185, 129, 0.6);
    }

    #noBtn {
      background: linear-gradient(135deg, var(--pink), var(--dark-pink));
      color: white;
      z-index: 5;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    .hint {
      margin-top: 25px;
      font-size: 17px;
      color: rgba(255, 255, 255, 0.8);
      font-style: italic;
    }

    /* Loading */
    #loading {
      position: absolute;
      inset: 0;
      background: var(--darker);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 300;
      transition: opacity 0.5s ease;
    }

    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #loading h2 {
      font-family: 'Cinzel Decorative', serif;
      font-size: 48px;
      margin-bottom: 30px;
      background: linear-gradient(135deg, var(--pink), var(--gold));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .spinner {
      width: 60px;
      height: 60px;
      border: 5px solid rgba(255, 107, 157, 0.2);
      border-top-color: var(--pink);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Floating particles */
    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.7; }
      50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
    }

    .particle {
      position: absolute;
      pointer-events: none;
      animation: float 4s ease-in-out infinite;
      font-size: 20px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD -->
    <div id="hud">
      <div class="hud-item">
        <span class="hud-icon">üó∫Ô∏è</span>
        <span>Level: <span class="hud-value" id="levelName">Meadow</span></span>
      </div>
      <div class="hud-item">
        <span class="hud-icon">üåπ</span>
        <span>Roses: <span class="hud-value" id="roseCount">0/3</span></span>
      </div>
      <div class="hud-item">
        <span class="hud-icon">üîë</span>
        <span>Key: <span class="hud-value" id="keyStatus">No</span></span>
      </div>
      <div id="healthBar" class="hud-item" style="padding: 4px; width: 220px;">
        <div id="healthFill" style="width: 100%;"></div>
        <div id="healthText">‚ù§Ô∏è 100 / 100</div>
      </div>
    </div>

    <!-- Story Box -->
    <div id="storyBox">
      <h3 id="storyTitle">Story</h3>
      <p id="storyText"></p>
      <button id="storyBtn">Continue</button>
    </div>

    <!-- Controls -->
    <div id="controls">
      <div><strong>ARROW KEYS</strong> or <strong>WASD</strong> - Move Princess</div>
      <div><strong>SPACE</strong> - Attack / Interact</div>
      <div style="margin-top: 10px; color: var(--light-pink);">üíñ A magical adventure awaits! üíñ</div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Modal -->
    <div id="modal">
      <div id="modalContent">
        <h1>My Dearest Princess üíñ</h1>
        <p>After your brave journey through enchanted lands, battling monsters, and proving your courage... I have one question:</p>
        <p style="font-size: 32px; margin-top: 20px; margin-bottom: 30px; color: var(--gold);">Will you be my Valentine?</p>
        <div class="button-container">
          <button class="btn" id="yesBtn">Yes! üíò</button>
          <button class="btn" id="noBtn">No üôà</button>
        </div>
        <div class="hint">(The "No" button is quite shy... üòè)</div>
      </div>
    </div>

    <!-- Loading -->
    <div id="loading">
      <h2>‚ú® Loading Your Adventure ‚ú®</h2>
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    // ============================================
    // GAME CONFIGURATION
    // ============================================
    const CONFIG = {
      playerSpeed: 3,
      enemySpeed: 1.5,
      maxHealth: 100,
      attackRange: 50,
      attackDamage: 34,
      enemyDamage: 15
    };

    // ============================================
    // CANVAS SETUP
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ============================================
    // GAME STATE
    // ============================================
    const state = {
      level: 0,
      roses: 0,
      hasKey: false,
      playerX: 100,
      playerY: 100,
      playerDir: 'down',
      health: CONFIG.maxHealth,
      keys: {},
      interactables: [],
      pickups: [],
      walls: [],
      enemies: [],
      decorations: [],
      projectiles: [],
      animFrame: 0,
      walkCycle: 0,
      attacking: false,
      attackCooldown: 0,
      invulnerable: 0,
      gamePaused: false
    };

    // ============================================
    // UI ELEMENTS
    // ============================================
    const hud = {
      levelName: document.getElementById('levelName'),
      roseCount: document.getElementById('roseCount'),
      keyStatus: document.getElementById('keyStatus'),
      healthFill: document.getElementById('healthFill'),
      healthText: document.getElementById('healthText'),
      toast: document.getElementById('toast'),
      modal: document.getElementById('modal'),
      loading: document.getElementById('loading'),
      storyBox: document.getElementById('storyBox'),
      storyTitle: document.getElementById('storyTitle'),
      storyText: document.getElementById('storyText')
    };

    function updateHUD() {
      const levelNames = ['Enchanted Meadow', 'Dark Forest', 'Castle Battleground'];
      hud.levelName.textContent = levelNames[state.level];
      hud.roseCount.textContent = `${state.roses}/3`;
      hud.keyStatus.textContent = state.hasKey ? 'Yes' : 'No';
      
      const healthPercent = (state.health / CONFIG.maxHealth) * 100;
      hud.healthFill.style.width = healthPercent + '%';
      hud.healthText.textContent = `‚ù§Ô∏è ${state.health} / ${CONFIG.maxHealth}`;
    }

    function showToast(message, duration = 2000) {
      hud.toast.textContent = message;
      hud.toast.classList.add('show');
      setTimeout(() => hud.toast.classList.remove('show'), duration);
    }

    function showStory(title, text) {
      state.gamePaused = true;
      hud.storyTitle.textContent = title;
      hud.storyText.textContent = text;
      hud.storyBox.classList.add('show');
    }

    function closeStory() {
      state.gamePaused = false;
      hud.storyBox.classList.remove('show');
    }
    
    // Make closeStory globally accessible
    window.closeStory = closeStory;

    function showModal() {
      state.gamePaused = true;
      
      // Reset button positions
      const yesBtn = document.getElementById('yesBtn');
      const noBtn = document.getElementById('noBtn');
      
      yesBtn.style.left = '35%';
      yesBtn.style.top = '50%';
      yesBtn.style.transform = 'translateY(-50%)';
      
      noBtn.style.left = '65%';
      noBtn.style.top = '50%';
      noBtn.style.transform = 'translateY(-50%)';
      
      hud.modal.classList.add('show');
    }

    function hideModal() {
      state.gamePaused = false;
      hud.modal.classList.remove('show');
    }

    // ============================================
    // AUDIO SYSTEM
    // ============================================
    let audioCtx = null;
    let musicPlaying = false;
    let musicInterval = null;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playNote(frequency, duration, type = 'sine', volume = 0.1) {
      if (!audioCtx) return;
      
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.type = type;
      osc.frequency.value = frequency;
      
      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.01);
      gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
      
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + duration);
    }

    function playPickupSound() {
      playNote(800, 0.1, 'square', 0.15);
      setTimeout(() => playNote(1000, 0.1, 'square', 0.15), 50);
    }

    function playAttackSound() {
      playNote(400, 0.15, 'sawtooth', 0.2);
    }

    function playHitSound() {
      playNote(200, 0.2, 'sawtooth', 0.25);
    }

    function playInteractSound() {
      playNote(600, 0.12, 'triangle', 0.18);
    }

    const melodyNotes = [523, 659, 784, 659, 698, 587, 523, 587, 659, 784, 880, 784, 698, 659, 587, 523];
    let melodyIndex = 0;

    function startMusic() {
      initAudio();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      
      musicPlaying = true;
      melodyIndex = 0;
      
      musicInterval = setInterval(() => {
        if (musicPlaying) {
          playNote(melodyNotes[melodyIndex], 0.35, 'triangle', 0.06);
          playNote(melodyNotes[melodyIndex] / 2, 0.35, 'sine', 0.04);
          melodyIndex = (melodyIndex + 1) % melodyNotes.length;
        }
      }, 350);
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd', ' '].includes(key)) {
        e.preventDefault();
        state.keys[key] = true;
      }
    });

    window.addEventListener('keyup', (e) => {
      state.keys[e.key.toLowerCase()] = false;
    });

    // ============================================
    // DRAWING FUNCTIONS
    // ============================================
    function drawGround(color1, color2) {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, color1);
      gradient.addColorStop(1, color2);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawWall(x, y, width, height, color) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(x + 5, y + 5, width, height);
      
      const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, shadeColor(color, -20));
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, width, height);
      
      ctx.strokeStyle = shadeColor(color, -40);
      ctx.lineWidth = 3;
      ctx.strokeRect(x, y, width, height);
    }

    function shadeColor(color, percent) {
      const num = parseInt(color.slice(1), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255))
        .toString(16).slice(1);
    }

    function drawTree(x, y) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.ellipse(x, y + 45, 18, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#8b4513';
      ctx.fillRect(x - 8, y, 16, 40);
      
      ctx.fillStyle = '#2d5016';
      ctx.beginPath();
      ctx.moveTo(x, y - 30);
      ctx.lineTo(x - 30, y + 10);
      ctx.lineTo(x + 30, y + 10);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(x, y - 20);
      ctx.lineTo(x - 25, y);
      ctx.lineTo(x + 25, y);
      ctx.closePath();
      ctx.fill();
    }

    function drawFlower(x, y, color) {
      ctx.fillStyle = '#2ecc71';
      ctx.fillRect(x - 1, y + 10, 2, 15);
      
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x + Math.cos(angle) * 8, y + 10 + Math.sin(angle) * 8, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.arc(x, y + 10, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawRock(x, y, size) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(x, y + size - 2, size * 0.8, size * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();

      const gradient = ctx.createRadialGradient(x - size/4, y - size/4, 0, x, y, size);
      gradient.addColorStop(0, '#9ca3af');
      gradient.addColorStop(1, '#6b7280');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = '#4b5563';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawBush(x, y) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.ellipse(x, y + 22, 20, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#22c55e';
      ctx.beginPath();
      ctx.arc(x - 12, y + 10, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 12, y + 10, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawRose(x, y) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.ellipse(x, y + 35, 15, 5, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#2ecc71';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x, y + 30);
      ctx.quadraticCurveTo(x - 5, y + 15, x, y);
      ctx.stroke();

      ctx.fillStyle = '#27ae60';
      ctx.beginPath();
      ctx.ellipse(x - 8, y + 15, 8, 4, -Math.PI / 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 8, y + 20, 8, 4, Math.PI / 4, 0, Math.PI * 2);
      ctx.fill();

      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const px = x + Math.cos(angle) * 12;
        const py = y - 5 + Math.sin(angle) * 12;
        
        ctx.fillStyle = '#ff6b9d';
        ctx.beginPath();
        ctx.arc(px, py, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      const gradient = ctx.createRadialGradient(x, y - 5, 0, x, y - 5, 10);
      gradient.addColorStop(0, '#ff4d7d');
      gradient.addColorStop(1, '#ff6b9d');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y - 5, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.beginPath();
      ctx.arc(x - 3, y - 8, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawPortal(x, y, label) {
      const time = Date.now() / 1000;
      
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
      gradient.addColorStop(0, 'rgba(64, 255, 170, 0.4)');
      gradient.addColorStop(1, 'rgba(64, 255, 170, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(x - 60, y - 60, 120, 120);

      for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(time + i * Math.PI / 3);
        
        ctx.strokeStyle = `rgba(64, 255, 170, ${0.6 - i * 0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, 30 + i * 15, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
      }

      const centerGrad = ctx.createRadialGradient(x, y, 0, x, y, 25);
      centerGrad.addColorStop(0, '#40ffaa');
      centerGrad.addColorStop(1, '#00d4aa');
      ctx.fillStyle = centerGrad;
      ctx.beginPath();
      ctx.arc(x, y, 25, 0, Math.PI * 2);
      ctx.fill();

      for (let i = 0; i < 5; i++) {
        const angle = time * 2 + i * (Math.PI * 2 / 5);
        const dist = 35 + Math.sin(time * 3) * 5;
        const sx = x + Math.cos(angle) * dist;
        const sy = y + Math.sin(angle) * dist;
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(sx, sy, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.save();
      ctx.font = 'bold 20px Cinzel Decorative, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillText(label, x + 2, y - 62);
      ctx.fillStyle = 'white';
      ctx.fillText(label, x, y - 64);
      ctx.restore();
      
      // Show "Press SPACE" when player is near
      const dist = Math.hypot(state.playerX - x, state.playerY - y);
      if (dist < 80) {
        ctx.save();
        ctx.font = 'bold 16px Poppins, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(x - 70, y + 50, 140, 30);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('Press SPACE to Enter', x, y + 65);
        ctx.restore();
      }
    }

    function drawCupid(x, y) {
      const time = Date.now() / 1000;
      const hover = Math.sin(time * 2) * 5;
      const cy = y + hover;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.ellipse(x, y + 40, 20, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(x, cy - 35, 18, 0, Math.PI * 2);
      ctx.stroke();

      ctx.fillStyle = 'rgba(185, 192, 255, 0.8)';
      
      ctx.save();
      ctx.translate(x - 25, cy);
      ctx.rotate(Math.sin(time * 3) * 0.2);
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 30, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#9da5ff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(x + 25, cy);
      ctx.rotate(-Math.sin(time * 3) * 0.2);
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 30, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#9da5ff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      const bodyGrad = ctx.createRadialGradient(x, cy, 0, x, cy, 25);
      bodyGrad.addColorStop(0, '#fff5e6');
      bodyGrad.addColorStop(1, '#ffe0cc');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.arc(x, cy, 25, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(x - 8, cy - 5, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 8, cy - 5, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, cy + 2, 10, 0.2 * Math.PI, 0.8 * Math.PI);
      ctx.stroke();

      const heartY = cy - 50 + Math.sin(time * 4) * 3;
      drawHeart(x, heartY, 12, '#ff6b9d');
      
      // Show "Press SPACE" when player is near
      const dist = Math.hypot(state.playerX - x, state.playerY - y);
      if (dist < 80) {
        ctx.save();
        ctx.font = 'bold 16px Poppins, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(x - 70, cy + 50, 140, 30);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('Press SPACE to Talk', x, cy + 65);
        ctx.restore();
      }
    }

    function drawDoor(x, y) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(x + 5, y + 5, 60, 100);

      const doorGrad = ctx.createLinearGradient(x, y, x + 60, y);
      doorGrad.addColorStop(0, '#8b4513');
      doorGrad.addColorStop(0.5, '#a0522d');
      doorGrad.addColorStop(1, '#8b4513');
      ctx.fillStyle = doorGrad;
      ctx.fillRect(x, y, 60, 100);

      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 3;
      ctx.strokeRect(x + 8, y + 8, 44, 40);
      ctx.strokeRect(x + 8, y + 52, 44, 40);

      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 5;
      ctx.strokeRect(x - 3, y - 3, 66, 106);

      const knobGrad = ctx.createRadialGradient(x + 45, y + 55, 0, x + 45, y + 55, 5);
      knobGrad.addColorStop(0, '#ffd700');
      knobGrad.addColorStop(1, '#daa520');
      ctx.fillStyle = knobGrad;
      ctx.beginPath();
      ctx.arc(x + 45, y + 55, 5, 0, Math.PI * 2);
      ctx.fill();

      drawHeart(x + 30, y + 30, 10, '#ff6b9d');
      
      // Show "Press SPACE" when player is near
      const dist = Math.hypot(state.playerX - (x + 30), state.playerY - (y + 50));
      if (dist < 80) {
        ctx.save();
        ctx.font = 'bold 16px Poppins, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(x - 10, y + 115, 80, 30);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('Press SPACE', x + 30, y + 130);
        ctx.restore();
      }
    }

    function drawHeart(x, y, size, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, size / 4);
      ctx.bezierCurveTo(-size, -size / 2, -size * 1.5, size / 2, 0, size * 1.5);
      ctx.bezierCurveTo(size * 1.5, size / 2, size, -size / 2, 0, size / 4);
      ctx.fill();
      ctx.restore();
    }

    function drawEnemy(x, y, type, health) {
      const time = Date.now() / 1000;
      const bob = Math.sin(time * 3) * 3;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(x, y + 30, 15, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      if (type === 'slime') {
        const gradient = ctx.createRadialGradient(x, y + bob - 5, 0, x, y + bob - 5, 20);
        gradient.addColorStop(0, '#8b5cf6');
        gradient.addColorStop(1, '#6d28d9');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.ellipse(x, y + bob, 18, 15, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(x - 6, y + bob - 8, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#1e1b4b';
        ctx.beginPath();
        ctx.arc(x - 7, y + bob - 3, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 7, y + bob - 3, 3, 0, Math.PI * 2);
        ctx.fill();
      } else if (type === 'guard') {
        // Royal Guard - armored knight
        // Body armor
        const gradient = ctx.createRadialGradient(x, y + bob, 0, x, y + bob, 20);
        gradient.addColorStop(0, '#c0c0c0');
        gradient.addColorStop(1, '#707070');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.ellipse(x, y + bob, 16, 20, 0, 0, Math.PI * 2);
        ctx.fill();

        // Helmet
        ctx.fillStyle = '#9ca3af';
        ctx.beginPath();
        ctx.arc(x, y + bob - 15, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // Helmet visor
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(x - 10, y + bob - 17, 20, 6);
        
        // Shield
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.arc(x - 18, y + bob, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Sword
        ctx.fillStyle = '#9ca3af';
        ctx.save();
        ctx.translate(x + 18, y + bob - 5);
        ctx.rotate(Math.PI / 4);
        ctx.fillRect(-2, -15, 4, 20);
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-4, -17, 8, 4);
        ctx.restore();
        
        // Cape
        ctx.fillStyle = '#dc2626';
        ctx.beginPath();
        ctx.moveTo(x - 12, y + bob + 5);
        ctx.quadraticCurveTo(x - 15, y + bob + 20, x - 10, y + bob + 25);
        ctx.lineTo(x + 10, y + bob + 25);
        ctx.quadraticCurveTo(x + 15, y + bob + 20, x + 12, y + bob + 5);
        ctx.closePath();
        ctx.fill();
      } else {
        // Demon
        const gradient = ctx.createRadialGradient(x, y + bob, 0, x, y + bob, 18);
        gradient.addColorStop(0, '#ef4444');
        gradient.addColorStop(1, '#991b1b');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y + bob, 18, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#7f1d1d';
        ctx.beginPath();
        ctx.moveTo(x - 15, y + bob - 10);
        ctx.lineTo(x - 5, y + bob - 20);
        ctx.lineTo(x - 10, y + bob - 10);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x + 15, y + bob - 10);
        ctx.lineTo(x + 5, y + bob - 20);
        ctx.lineTo(x + 10, y + bob - 10);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.arc(x - 6, y + bob - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 6, y + bob - 2, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y + bob + 4, 6, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.stroke();
      }

      // Health bar
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(x - 20, y + bob - 30, 40, 4);
      const healthPercent = health / 100;
      ctx.fillStyle = '#22c55e';
      ctx.fillRect(x - 20, y + bob - 30, 40 * healthPercent, 4);
    }

    function drawPrincess(x, y, dir, walking) {
      const time = Date.now() / 1000;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(x, y + 32, 12, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      const bob = walking ? Math.sin(state.walkCycle * 0.3) * 2 : 0;
      const py = y + bob;

      const dressGrad = ctx.createLinearGradient(x, py - 10, x, py + 25);
      dressGrad.addColorStop(0, '#ff6b9d');
      dressGrad.addColorStop(1, '#ff4d7d');
      ctx.fillStyle = dressGrad;
      ctx.beginPath();
      ctx.moveTo(x - 15, py + 5);
      ctx.quadraticCurveTo(x - 18, py + 25, x - 12, py + 25);
      ctx.lineTo(x + 12, py + 25);
      ctx.quadraticCurveTo(x + 18, py + 25, x + 15, py + 5);
      ctx.lineTo(x + 8, py - 5);
      ctx.lineTo(x - 8, py - 5);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 12, py + 25);
      ctx.lineTo(x + 12, py + 25);
      ctx.stroke();

      ctx.fillStyle = '#ffd700';
      ctx.fillRect(x - 10, py + 2, 20, 4);

      const armSwing = walking ? Math.sin(state.walkCycle * 0.3) * 5 : 0;
      
      ctx.fillStyle = '#ffe0cc';
      ctx.beginPath();
      ctx.arc(x - 12, py - 2 + armSwing, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 12, py - 2 - armSwing, 5, 0, Math.PI * 2);
      ctx.fill();

      if (state.attacking) {
        ctx.save();
        ctx.translate(x + 20, py);
        ctx.rotate(Math.PI / 4);
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(-3, -20, 6, 30);
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(-5, -15);
        ctx.lineTo(5, -15);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      ctx.fillStyle = '#ff6b9d';
      ctx.beginPath();
      ctx.ellipse(x, py - 5, 10, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ffe0cc';
      ctx.fillRect(x - 4, py - 15, 8, 6);

      const headGrad = ctx.createRadialGradient(x, py - 22, 0, x, py - 22, 12);
      headGrad.addColorStop(0, '#ffe0cc');
      headGrad.addColorStop(1, '#ffd4b3');
      ctx.fillStyle = headGrad;
      ctx.beginPath();
      ctx.arc(x, py - 22, 12, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#8b4513';
      ctx.beginPath();
      ctx.arc(x, py - 25, 13, Math.PI, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.ellipse(x - 10, py - 20, 6, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 10, py - 20, 6, 10, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.moveTo(x - 10, py - 30);
      ctx.lineTo(x - 7, py - 35);
      ctx.lineTo(x - 4, py - 30);
      ctx.lineTo(x, py - 38);
      ctx.lineTo(x + 4, py - 30);
      ctx.lineTo(x + 7, py - 35);
      ctx.lineTo(x + 10, py - 30);
      ctx.lineTo(x + 8, py - 28);
      ctx.lineTo(x - 8, py - 28);
      ctx.closePath();
      ctx.fill();

      const jewels = [-6, 0, 6];
      ctx.fillStyle = '#ff6b9d';
      jewels.forEach(offset => {
        ctx.beginPath();
        ctx.arc(x + offset, py - 32, 2.5, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(x - 4, py - 23, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 4, py - 23, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, py - 20, 5, 0.2 * Math.PI, 0.8 * Math.PI);
      ctx.stroke();

      ctx.fillStyle = 'rgba(255, 182, 193, 0.5)';
      ctx.beginPath();
      ctx.arc(x - 8, py - 19, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 8, py - 19, 3, 0, Math.PI * 2);
      ctx.fill();

      if (state.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }
      ctx.globalAlpha = 1;
    }

    // ============================================
    // COLLISION DETECTION
    // ============================================
    function checkCollision(x, y, width, height) {
      for (const wall of state.walls) {
        if (x < wall.x + wall.width &&
            x + width > wall.x &&
            y < wall.y + wall.height &&
            y + height > wall.y) {
          return true;
        }
      }
      return false;
    }

    function checkPickup(x, y, radius) {
      for (let i = state.pickups.length - 1; i >= 0; i--) {
        const pickup = state.pickups[i];
        const dist = Math.hypot(x - pickup.x, y - pickup.y);
        if (dist < radius) {
          return pickup;
        }
      }
      return null;
    }

    function checkInteractable(x, y, radius) {
      for (const obj of state.interactables) {
        const dist = Math.hypot(x - obj.x, y - obj.y);
        if (dist < radius) {
          return obj;
        }
      }
      return null;
    }

    // ============================================
    // LEVEL BUILDING
    // ============================================
    function buildLevel(levelNum) {
      console.log('buildLevel called with:', levelNum);
      state.level = levelNum;
      state.walls = [];
      state.interactables = [];
      state.pickups = [];
      state.enemies = [];
      state.decorations = [];
      state.walkCycle = 0;
      state.attacking = false;
      state.attackCooldown = 0;

      // Don't call individual build functions here anymore
      // They will be called directly from portal actions
      
      updateHUD();
      console.log('buildLevel complete');
    }

    function buildMeadow() {
      console.log('Building Meadow level');
      
      state.level = 0;
      state.playerX = 100;
      state.playerY = 100;

      state.walls.push({ x: 0, y: 0, width: canvas.width, height: 20, color: '#ff6b9d' });
      state.walls.push({ x: 0, y: canvas.height - 20, width: canvas.width, height: 20, color: '#ff6b9d' });
      state.walls.push({ x: 0, y: 0, width: 20, height: canvas.height, color: '#a855f7' });
      state.walls.push({ x: canvas.width - 20, y: 0, width: 20, height: canvas.height, color: '#a855f7' });

      state.walls.push({ x: 200, y: 150, width: 20, height: 200, color: '#40ffaa' });
      state.walls.push({ x: 500, y: 300, width: 150, height: 20, color: '#40ffaa' });
      state.walls.push({ x: canvas.width - 250, y: 150, width: 20, height: 200, color: '#40ffaa' });
      state.walls.push({ x: 350, y: 500, width: 200, height: 20, color: '#40ffaa' });

      state.pickups.push({ x: 150, y: 250, type: 'rose' });
      state.pickups.push({ x: canvas.width - 150, y: 400, type: 'rose' });
      state.pickups.push({ x: canvas.width / 2, y: 150, type: 'rose' });

      for (let i = 0; i < 15; i++) {
        state.decorations.push({ 
          x: 50 + Math.random() * (canvas.width - 100), 
          y: 50 + Math.random() * (canvas.height - 100), 
          type: 'flower',
          color: ['#ff6b9d', '#a855f7', '#fbbf24'][Math.floor(Math.random() * 3)]
        });
      }

      for (let i = 0; i < 8; i++) {
        state.decorations.push({ 
          x: 80 + Math.random() * (canvas.width - 160), 
          y: 80 + Math.random() * (canvas.height - 160), 
          type: 'bush'
        });
      }

      for (let i = 0; i < 10; i++) {
        state.decorations.push({ 
          x: 60 + Math.random() * (canvas.width - 120), 
          y: 60 + Math.random() * (canvas.height - 120), 
          type: 'rock',
          size: 10 + Math.random() * 15
        });
      }

      // Portal to forest
      state.interactables.push({
        x: canvas.width / 2,
        y: canvas.height - 100,
        type: 'portal',
        label: '‚ú® To Dark Forest ‚ú®',
        action: function() {
          console.log('Portal activated, roses:', state.roses);
          if (state.roses >= 3) {
            console.log('Transitioning to forest');
            state.spacePressed = false; // Reset space immediately
            state.keys = {}; // Clear all key states
            state.level = 1;
            state.playerX = 100;
            state.playerY = 100;
            state.health = CONFIG.maxHealth;
            state.walls = [];
            state.interactables = [];
            state.pickups = [];
            state.enemies = [];
            state.decorations = [];
            state.walkCycle = 0;
            state.attacking = false;
            state.attackCooldown = 0;
            buildForest();
            updateHUD();
            showToast('üåπ Entering the Dark Forest! üåπ', 2000);
            setTimeout(() => {
              showStory('Chapter 2: The Dark Forest', 'The princess enters a dark, monster-infested forest. She must defeat the creatures to reach Cupid and obtain the magical key to the castle!');
            }, 500);
          } else {
            showToast(`Find ${3 - state.roses} more rose${3 - state.roses > 1 ? 's' : ''}! üåπ`, 1500);
          }
        }
      });

      state.playerX = 100;
      state.playerY = 100;
    }

    function buildForest() {
      console.log('Building Forest level');
      
      state.level = 1;

      state.walls.push({ x: 0, y: 0, width: canvas.width, height: 20, color: '#1a5c3a' });
      state.walls.push({ x: 0, y: canvas.height - 20, width: canvas.width, height: 20, color: '#1a5c3a' });
      state.walls.push({ x: 0, y: 0, width: 20, height: canvas.height, color: '#1a5c3a' });
      state.walls.push({ x: canvas.width - 20, y: 0, width: 20, height: canvas.height, color: '#1a5c3a' });

      state.walls.push({ x: canvas.width / 2 - 150, y: 200, width: 20, height: 250, color: '#a855f7' });
      state.walls.push({ x: canvas.width / 2 + 130, y: 200, width: 20, height: 250, color: '#a855f7' });
      state.walls.push({ x: canvas.width / 2 - 150, y: 200, width: 300, height: 20, color: '#ff6b9d' });
      
      state.walls.push({ x: canvas.width / 2 - 200, y: 450, width: 150, height: 20, color: '#40ffaa' });
      state.walls.push({ x: canvas.width / 2 + 50, y: 450, width: 150, height: 20, color: '#40ffaa' });

      for (let i = 0; i < 8; i++) {
        state.decorations.push({ 
          x: 100 + Math.random() * (canvas.width - 200), 
          y: 100 + Math.random() * (canvas.height - 200), 
          type: 'tree'
        });
      }

      for (let i = 0; i < 6; i++) {
        state.decorations.push({ 
          x: 80 + Math.random() * (canvas.width - 160), 
          y: 80 + Math.random() * (canvas.height - 160), 
          type: 'rock',
          size: 15 + Math.random() * 20
        });
      }

      state.enemies.push({ x: 300, y: 200, type: 'slime', health: 100, speed: 1.2 });
      state.enemies.push({ x: canvas.width - 300, y: 300, type: 'demon', health: 100, speed: 1.0 });
      state.enemies.push({ x: 400, y: 500, type: 'slime', health: 100, speed: 1.3 });

      state.interactables.push({
        x: canvas.width / 2,
        y: 330,
        type: 'cupid',
        action: () => {
          if (state.enemies.length > 0) {
            showToast('Cupid: Defeat all monsters first! ‚öîÔ∏è', 2000);
            return;
          }
          if (!state.hasKey) {
            state.hasKey = true;
            playPickupSound();
            showToast('üíò Cupid: "You\'ve proven your courage!\nHere\'s the key to the castle!" üíò', 3500);
            updateHUD();
          } else {
            showToast('Cupid: "The castle awaits, brave Princess!" üë∏‚ú®', 2000);
          }
        }
      });

      // Portal to castle
      state.interactables.push({
        x: canvas.width / 2,
        y: 100,
        type: 'portal',
        label: 'üè∞ To Castle üè∞',
        action: function() {
          console.log('Castle portal activated, hasKey:', state.hasKey);
          if (state.hasKey) {
            console.log('Transitioning to castle');
            state.spacePressed = false; // Reset space immediately
            state.keys = {}; // Clear all key states
            state.level = 2;
            state.playerX = 100;
            state.playerY = 100;
            state.walls = [];
            state.interactables = [];
            state.pickups = [];
            state.enemies = [];
            state.decorations = [];
            state.walkCycle = 0;
            state.attacking = false;
            state.attackCooldown = 0;
            buildCastle();
            updateHUD();
            showToast('üîë Entering the Royal Castle! üîë', 2000);
            setTimeout(() => {
              showStory('Chapter 3: The Royal Castle', 'The princess arrives at the majestic castle. Behind the enchanted door lies her destiny... and perhaps, true love.');
            }, 500);
          } else {
            showToast('You need the key from Cupid! üîë', 1500);
          }
        }
      });
    }

    function buildCastle() {
      console.log('Building Castle level');
      
      state.level = 2;

      // Border walls - bigger map
      state.walls.push({ x: 0, y: 0, width: canvas.width, height: 20, color: '#8b4513' });
      state.walls.push({ x: 0, y: canvas.height - 20, width: canvas.width, height: 20, color: '#8b4513' });
      state.walls.push({ x: 0, y: 0, width: 20, height: canvas.height, color: '#8b4513' });
      state.walls.push({ x: canvas.width - 20, y: 0, width: 20, height: canvas.height, color: '#8b4513' });

      // Create a more complex castle layout with multiple rooms/corridors
      // Main central wall
      state.walls.push({ x: canvas.width / 2 - 150, y: canvas.height / 2 - 10, width: 300, height: 20, color: '#ffd700' });
      
      // Left room walls
      state.walls.push({ x: 200, y: 100, width: 20, height: 250, color: '#8b4513' });
      state.walls.push({ x: 200, y: 100, width: 150, height: 20, color: '#8b4513' });
      
      // Right room walls
      state.walls.push({ x: canvas.width - 220, y: 350, width: 20, height: 250, color: '#8b4513' });
      state.walls.push({ x: canvas.width - 370, y: 580, width: 150, height: 20, color: '#8b4513' });
      
      // Additional maze-like walls
      state.walls.push({ x: 450, y: 200, width: 20, height: 180, color: '#8b4513' });
      state.walls.push({ x: canvas.width - 470, y: 150, width: 20, height: 200, color: '#8b4513' });
      
      // Lower section walls
      state.walls.push({ x: 300, y: canvas.height - 170, width: 200, height: 20, color: '#8b4513' });
      state.walls.push({ x: canvas.width - 500, y: canvas.height - 170, width: 200, height: 20, color: '#8b4513' });

      // Add decorative rocks
      for (let i = 0; i < 15; i++) {
        state.decorations.push({ 
          x: 100 + Math.random() * (canvas.width - 200), 
          y: 100 + Math.random() * (canvas.height - 200), 
          type: 'rock',
          size: 12 + Math.random() * 18
        });
      }

      // Add Royal Guards - stronger enemies that must be defeated
      state.enemies.push({ x: 400, y: 250, type: 'guard', health: 100, speed: 1.4 });
      state.enemies.push({ x: canvas.width - 400, y: 350, type: 'guard', health: 100, speed: 1.3 });
      state.enemies.push({ x: 600, y: 500, type: 'guard', health: 100, speed: 1.5 });
      state.enemies.push({ x: canvas.width - 600, y: 200, type: 'guard', health: 100, speed: 1.2 });

      // The enchanted door - requires defeating all guards
      state.interactables.push({
        x: canvas.width - 120,
        y: canvas.height / 2 - 50,
        type: 'door',
        action: () => {
          if (state.enemies.length > 0) {
            showToast('üõ°Ô∏è Defeat all the royal guards first! ‚öîÔ∏è', 2000);
            return;
          }
          if (state.hasKey) {
            playInteractSound();
            showModal();
          } else {
            showToast('üö™ The door is locked! üîí', 2000);
          }
        }
      });
    }

    // ============================================
    // GAME UPDATE
    // ============================================
    function update(deltaTime) {
      if (state.gamePaused) return;

      state.animFrame++;
      if (state.attackCooldown > 0) state.attackCooldown--;
      if (state.invulnerable > 0) state.invulnerable--;

      let dx = 0;
      let dy = 0;
      let moving = false;

      if (state.keys['arrowup'] || state.keys['w']) {
        dy -= CONFIG.playerSpeed;
        state.playerDir = 'up';
        moving = true;
      }
      if (state.keys['arrowdown'] || state.keys['s']) {
        dy += CONFIG.playerSpeed;
        state.playerDir = 'down';
        moving = true;
      }
      if (state.keys['arrowleft'] || state.keys['a']) {
        dx -= CONFIG.playerSpeed;
        state.playerDir = 'left';
        moving = true;
      }
      if (state.keys['arrowright'] || state.keys['d']) {
        dx += CONFIG.playerSpeed;
        state.playerDir = 'right';
        moving = true;
      }

      if (moving) {
        state.walkCycle++;
      }

      const newX = state.playerX + dx;
      const newY = state.playerY + dy;

      if (!checkCollision(newX - 10, state.playerY - 15, 20, 30)) {
        state.playerX = newX;
      }
      if (!checkCollision(state.playerX - 10, newY - 15, 20, 30)) {
        state.playerY = newY;
      }

      const pickup = checkPickup(state.playerX, state.playerY, 30);
      if (pickup) {
        const index = state.pickups.indexOf(pickup);
        state.pickups.splice(index, 1);
        
        if (pickup.type === 'rose') {
          state.roses++;
          playPickupSound();
          
          const messages = [
            'üåπ First enchanted rose! üåπ\nTwo more to find!',
            'üåπüåπ Second rose obtained! üåπüåπ\nOne more to go!',
            'üåπüåπüåπ All three roses collected! üåπüåπüåπ\nThe portal awaits!'
          ];
          showToast(messages[state.roses - 1], 2200);
          updateHUD();
        }
      }

      if (state.keys[' '] && !state.spacePressed) {
        state.spacePressed = true;
        
        // Check for interactables first (portals, NPCs, doors)
        const obj = checkInteractable(state.playerX, state.playerY, 80);
        if (obj) {
          console.log('Interacting with:', obj.type);
          playInteractSound();
          try {
            obj.action();
          } catch (error) {
            console.error('Error in interaction:', error);
          }
        } else {
          // Only attack if not interacting with something
          if (state.attackCooldown === 0) {
            state.attacking = true;
            state.attackCooldown = 20;
            playAttackSound();
            
            for (let i = state.enemies.length - 1; i >= 0; i--) {
              const enemy = state.enemies[i];
              const dist = Math.hypot(state.playerX - enemy.x, state.playerY - enemy.y);
              if (dist < CONFIG.attackRange) {
                enemy.health -= CONFIG.attackDamage;
                showToast('Hit! üí•', 800);
                
                if (enemy.health <= 0) {
                  state.enemies.splice(i, 1);
                  playPickupSound();
                  showToast('Monster defeated! ‚öîÔ∏è‚ú®', 1500);
                }
              }
            }
            
            setTimeout(() => { state.attacking = false; }, 200);
          }
        }
      }
      if (!state.keys[' ']) {
        state.spacePressed = false;
      }

      for (const enemy of state.enemies) {
        const dx = state.playerX - enemy.x;
        const dy = state.playerY - enemy.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
          enemy.x += (dx / dist) * enemy.speed;
          enemy.y += (dy / dist) * enemy.speed;
        }
        
        if (dist < 30 && state.invulnerable === 0) {
          state.health -= CONFIG.enemyDamage;
          state.invulnerable = 60;
          playHitSound();
          showToast('Ouch! üíî', 1000);
          updateHUD();
          
          if (state.health <= 0) {
            state.health = CONFIG.maxHealth;
            state.playerX = 100;
            state.playerY = 100;
            showToast('You fainted! Respawning... üí´', 2000);
            updateHUD();
          }
        }
      }
    }

    // ============================================
    // RENDER
    // ============================================
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (state.level === 0) {
        drawGround('#87ceeb', '#90ee90');
      } else if (state.level === 1) {
        drawGround('#1a5c3a', '#0d2818');
      } else {
        drawGround('#2c2f4a', '#1a1d2e');
      }

      for (const deco of state.decorations) {
        if (deco.type === 'flower') {
          drawFlower(deco.x, deco.y, deco.color);
        } else if (deco.type === 'bush') {
          drawBush(deco.x, deco.y);
        } else if (deco.type === 'rock') {
          drawRock(deco.x, deco.y, deco.size);
        } else if (deco.type === 'tree') {
          drawTree(deco.x, deco.y);
        }
      }

      for (const wall of state.walls) {
        drawWall(wall.x, wall.y, wall.width, wall.height, wall.color);
      }

      for (const pickup of state.pickups) {
        if (pickup.type === 'rose') {
          drawRose(pickup.x, pickup.y);
        }
      }

      for (const obj of state.interactables) {
        if (obj.type === 'portal') {
          drawPortal(obj.x, obj.y, obj.label);
        } else if (obj.type === 'cupid') {
          drawCupid(obj.x, obj.y);
        } else if (obj.type === 'door') {
          drawDoor(obj.x, obj.y);
        }
      }

      for (const enemy of state.enemies) {
        drawEnemy(enemy.x, enemy.y, enemy.type, enemy.health);
      }

      drawPrincess(state.playerX, state.playerY, state.playerDir, state.walkCycle > 0);
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;

    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      update(deltaTime);
      render();

      requestAnimationFrame(gameLoop);
    }

    // ============================================
    // MODAL HANDLERS
    // ============================================
    let noDodgeCount = 0;
    const noBtn = document.getElementById('noBtn');

    function dodgeNoButton() {
      noDodgeCount++;
      
      const container = document.querySelector('.button-container');
      const containerRect = container.getBoundingClientRect();
      
      // Predefined safe positions (corners and edges) - percentages relative to container
      const safePositions = [
        { left: '10%', top: '15%' },    // Top-left corner
        { left: '85%', top: '15%' },    // Top-right corner  
        { left: '10%', top: '75%' },    // Bottom-left corner
        { left: '85%', top: '75%' },    // Bottom-right corner
        { left: '10%', top: '45%' },    // Mid-left edge
        { left: '85%', top: '45%' },    // Mid-right edge
        { left: '50%', top: '10%' },    // Top-center edge
        { left: '50%', top: '80%' }     // Bottom-center edge
      ];
      
      // Pick a random safe position
      const pos = safePositions[Math.floor(Math.random() * safePositions.length)];
      
      // Move button to the safe position
      noBtn.style.left = pos.left;
      noBtn.style.top = pos.top;
      noBtn.style.transform = 'translate(-50%, -50%)';
      
      const messages = [
        'Oops! Wrong button! üòÑ',
        'The button ran away! üèÉ‚Äç‚ôÇÔ∏èüí®',
        'Nice try, Princess! üòè',
        'Nope! Try again! üíñ',
        'You can\'t escape destiny! ‚ú®',
        'That button is shy! üôà',
        'Wrong choice! üíò',
        'Love always wins! üíï',
        'Catch me if you can! üòÜ',
        'Not today! üí´'
      ];
      
      showToast(messages[noDodgeCount % messages.length], 1200);
    }

    document.getElementById('yesBtn').addEventListener('click', () => {
      hideModal();
      
      // Create a massive heart explosion with smooth timing
      for (let i = 0; i < 120; i++) {
        setTimeout(() => {
          const heart = document.createElement('div');
          heart.className = 'particle';
          heart.textContent = ['üíñ', 'üíù', 'üíï', 'üíó', '‚ú®', 'üåü', 'üíò', '‚ù§Ô∏è', 'üåπ'][Math.floor(Math.random() * 9)];
          heart.style.position = 'fixed';
          heart.style.left = '50%';
          heart.style.top = '50%';
          heart.style.fontSize = Math.random() * 45 + 25 + 'px';
          heart.style.pointerEvents = 'none';
          heart.style.zIndex = '1000';
          document.body.appendChild(heart);
          
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * 500 + 200;
          
          heart.animate([
            { 
              transform: 'translate(-50%, -50%) scale(0) rotate(0deg)',
              opacity: 1 
            },
            { 
              transform: `translate(calc(-50% + ${Math.cos(angle) * distance}px), calc(-50% + ${Math.sin(angle) * distance}px)) scale(2) rotate(${Math.random() * 1080}deg)`,
              opacity: 0 
            }
          ], {
            duration: 3500 + Math.random() * 2000,
            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
          }).onfinish = () => heart.remove();
        }, i * 30);
      }
      
      // Show celebration message with delay so hearts appear first, and much longer duration
      setTimeout(() => {
        showToast('üéâüéâ SHE SAID YES! üéâüéâ\n\nüíñ Happy Valentine\'s Day,  üíñ\n\n‚ú® You Complete Me! ‚ú®\n\nüåπ Forever and Always! üåπ', 10000);
      }, 400);
    });

    noBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dodgeNoButton();
    });

    noBtn.addEventListener('mouseenter', (e) => {
      e.preventDefault();
      dodgeNoButton();
    });
    
    noBtn.addEventListener('mousemove', (e) => {
      e.preventDefault();
      dodgeNoButton();
    });

    noBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dodgeNoButton();
    });
    
    noBtn.addEventListener('touchmove', (e) => {
      e.preventDefault();
      dodgeNoButton();
    });

    // ============================================
    // INITIALIZATION
    // ============================================
    function init() {
      console.log('Initializing game');
      buildMeadow();
      updateHUD();
      
      initAudio();
      startMusic();
      
      setTimeout(() => {
        hud.loading.classList.add('hidden');
        requestAnimationFrame(gameLoop);
        // Show intro story after loading
        setTimeout(() => {
          showStory('Chapter 1: The Quest Begins', 'In a land of magic and wonder, a brave princess sets out on a quest to find three enchanted roses. Little does she know, this journey will lead her to discover true love...');
        }, 500);
      }, 1500);
    }

    // Set up story button listener immediately
    document.addEventListener('DOMContentLoaded', function() {
      const storyBtn = document.getElementById('storyBtn');
      if (storyBtn) {
        storyBtn.addEventListener('click', function() {
          closeStory();
        });
      }
    });

    window.addEventListener('click', () => {
      initAudio();
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }, { once: true });

    // Start game when page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>
